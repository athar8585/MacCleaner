#!/usr/bin/env python3
"""
MacCleaner Guardian - INDICATEUR BARRE DE MENU SIMPLE
Version simple utilisant les notifications macOS et scripts AppleScript
"""

import subprocess
import threading
import time
import json
import os
from datetime import datetime
from pathlib import Path

class SimpleMenuBarGuardian:
    """Indicateur simple dans la barre de menu via AppleScript"""
    
    def __init__(self):
        self.config_file = Path.home() / '.maccleaner_guardian.json'
        self.monitoring_active = True
        self.current_status = "optimal"
        
        # Configuration
        self.config = {
            'auto_cleanup_enabled': True,
            'monitoring_interval': 30,
            'auto_cleanup_threshold': 85,
            'memory_threshold': 80,
            'notifications_enabled': True,
            'last_cleanup': None
        }
        
        self.load_config()
        self.create_menu_bar_indicator()
    
    def load_config(self):
        """Charge la configuration"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    saved_config = json.load(f)
                    self.config.update(saved_config)
        except:
            pass
    
    def save_config(self):
        """Sauvegarde la configuration"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except:
            pass
    
    def create_menu_bar_indicator(self):
        """Cr√©e l'indicateur dans la barre de menu"""
        
        # Script AppleScript pour cr√©er l'indicateur persistant
        applescript = '''
        on run
            set statusText to "üõ°Ô∏è MacCleaner Guardian"
            
            -- Cr√©er une notification persistante qui reste dans le centre de notifications
            display notification "MacCleaner Guardian est actif et surveille votre Mac" with title "üõ°Ô∏è Guardian Actif" subtitle "Cliquez pour voir le statut"
            
            -- Cr√©er un script qui affiche le menu quand appel√©
            tell application "System Events"
                -- Optionnel: ajouter √† la barre de menu via un processus en arri√®re-plan
            end tell
            
            return "Guardian indicator created"
        end run
        '''
        
        try:
            subprocess.run(['osascript', '-e', applescript], 
                         capture_output=True, timeout=10)
            print("üõ°Ô∏è  Indicateur barre de menu cr√©√©")
        except Exception as e:
            print(f"‚ùå Erreur cr√©ation indicateur: {e}")
    
    def get_system_metrics(self):
        """R√©cup√®re les m√©triques syst√®me"""
        try:
            metrics = {}
            
            # Disque via df
            df_result = subprocess.run(['df', '-h', '/'], capture_output=True, text=True, timeout=5)
            if df_result.returncode == 0:
                lines = df_result.stdout.strip().split('\n')
                if len(lines) > 1:
                    fields = lines[1].split()
                    if len(fields) >= 5:
                        metrics['disk_percent'] = int(float(fields[4].replace('%', '')))
                        metrics['disk_free'] = fields[3]
            
            # M√©moire via vm_stat
            vm_result = subprocess.run(['vm_stat'], capture_output=True, text=True, timeout=5)
            if vm_result.returncode == 0:
                lines = vm_result.stdout.split('\n')
                free_pages = 0
                active_pages = 0
                
                for line in lines:
                    if 'Pages free:' in line:
                        free_pages = int(line.split()[2].replace('.', ''))
                    elif 'Pages active:' in line:
                        active_pages = int(line.split()[2].replace('.', ''))
                
                total_pages = free_pages + active_pages
                if total_pages > 0:
                    metrics['memory_percent'] = int((active_pages / total_pages) * 100)
                    metrics['memory_free_mb'] = int((free_pages * 4096) // (1024 * 1024))
            
            # CPU via uptime
            uptime_result = subprocess.run(['uptime'], capture_output=True, text=True, timeout=5)
            if uptime_result.returncode == 0:
                output = uptime_result.stdout
                if 'load averages:' in output:
                    load_avg_str = output.split('load averages:')[-1].strip().split()[0]
                    load_avg_str = load_avg_str.replace(',', '.')
                    metrics['cpu_percent'] = int(min(float(load_avg_str) * 25, 100))
            
            return metrics
            
        except Exception as e:
            print(f"‚ùå Erreur m√©triques: {e}")
            return {}
    
    def send_status_notification(self, status_text, details):
        """Envoie une notification de statut mise √† jour"""
        try:
            # Notification avec d√©tails syst√®me
            script = f'''
            display notification "{details}" with title "{status_text}" subtitle "MacCleaner Guardian" sound name ""
            '''
            
            subprocess.run(['osascript', '-e', script], 
                         capture_output=True, timeout=5)
        except:
            pass
    
    def create_interactive_menu(self, metrics):
        """Cr√©e un menu interactif avec les options"""
        disk_percent = metrics.get('disk_percent', 0)
        memory_percent = metrics.get('memory_percent', 0)
        cpu_percent = metrics.get('cpu_percent', 0)
        
        menu_script = f'''
        set statusInfo to "üìä √âTAT SYST√àME ({time.strftime("%H:%M")})\\n\\nüíæ Disque: {disk_percent}% ({metrics.get('disk_free', '--')} libre)\\nüß† M√©moire: {memory_percent}% ({metrics.get('memory_free_mb', 0)}MB libre)\\n‚ö° CPU: {cpu_percent}%\\n\\n"
        
        if {disk_percent} > 80 then
            set statusInfo to statusInfo & "‚ö†Ô∏è  Espace disque faible !\\n"
        end if
        
        if {memory_percent} > 75 then
            set statusInfo to statusInfo & "‚ö†Ô∏è  M√©moire satur√©e !\\n"
        end if
        
        set actionButtons to {{"üßπ Nettoyage Rapide", "‚ö° Optimisation", "üîÑ Actualiser", "‚öôÔ∏è Configuration", "‚ùå Fermer"}}
        
        set userChoice to choose from list actionButtons with title "üõ°Ô∏è MacCleaner Guardian" with prompt statusInfo default items {{"üîÑ Actualiser"}} OK button name "Ex√©cuter" cancel button name "Fermer"
        
        if userChoice is not false then
            set selectedAction to item 1 of userChoice
            return selectedAction
        else
            return "Fermer"
        end if
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', menu_script], 
                                  capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                action = result.stdout.strip()
                return action
            
        except Exception as e:
            print(f"‚ùå Erreur menu interactif: {e}")
        
        return None
    
    def handle_user_action(self, action):
        """Traite l'action choisie par l'utilisateur"""
        if action == "üßπ Nettoyage Rapide":
            self.perform_cleanup()
        elif action == "‚ö° Optimisation":
            self.perform_optimization()
        elif action == "üîÑ Actualiser":
            self.force_update()
        elif action == "‚öôÔ∏è Configuration":
            self.show_configuration()
        
    def perform_cleanup(self):
        """Effectue un nettoyage rapide"""
        try:
            self.send_notification("üßπ Nettoyage", "Nettoyage en cours...")
            
            actions = []
            
            # Vider la corbeille
            trash_path = Path.home() / '.Trash'
            if trash_path.exists():
                subprocess.run(['rm', '-rf', str(trash_path / '*')], 
                             shell=True, timeout=30, capture_output=True)
                actions.append("Corbeille vid√©e")
            
            # Nettoyer caches
            cache_paths = [
                Path.home() / 'Library/Caches/com.apple.Safari/WebKitCache',
                Path('/tmp')
            ]
            
            for cache_path in cache_paths:
                if cache_path.exists():
                    try:
                        subprocess.run([
                            'find', str(cache_path), 
                            '-type', 'f', '-mtime', '+7', 
                            '-delete'
                        ], timeout=60, capture_output=True)
                        actions.append(f"Cache {cache_path.name}")
                    except:
                        pass
            
            self.config['last_cleanup'] = datetime.now().isoformat()
            self.save_config()
            
            self.send_notification(
                "‚úÖ Nettoyage termin√©", 
                f"{len(actions)} optimisations appliqu√©es"
            )
            
            print(f"‚úÖ Nettoyage termin√©: {actions}")
            
        except Exception as e:
            print(f"‚ùå Erreur nettoyage: {e}")
            self.send_notification("‚ùå Erreur", "Nettoyage √©chou√©")
    
    def perform_optimization(self):
        """Effectue une optimisation syst√®me"""
        try:
            self.send_notification("‚ö° Optimisation", "Optimisation en cours...")
            
            # DNS flush
            subprocess.run(['sudo', 'dscacheutil', '-flushcache'], 
                         timeout=10, capture_output=True)
            
            # Purge m√©moire
            subprocess.run(['sudo', 'purge'], timeout=30, capture_output=True)
            
            self.send_notification("‚úÖ Optimisation OK", "Syst√®me optimis√©")
            print("‚ö° Optimisation termin√©e")
            
        except Exception as e:
            print(f"‚ùå Erreur optimisation: {e}")
            self.send_notification("‚ùå Erreur", "Optimisation √©chou√©e")
    
    def force_update(self):
        """Force une mise √† jour du statut"""
        self.update_system_status()
        self.send_notification("üîÑ Actualisation", "Statut mis √† jour")
    
    def show_configuration(self):
        """Affiche la configuration"""
        config_script = f'''
        set configText to "‚öôÔ∏è CONFIGURATION ACTUELLE\\n\\n"
        set configText to configText & "üßπ Nettoyage automatique: {'OUI' if self.config['auto_cleanup_enabled'] else 'NON'}\\n"
        set configText to configText & "üîî Notifications: {'OUI' if self.config['notifications_enabled'] else 'NON'}\\n"
        set configText to configText & "üìä Seuil disque: {self.config['auto_cleanup_threshold']}%\\n"
        set configText to configText & "üß† Seuil m√©moire: {self.config['memory_threshold']}%\\n"
        set configText to configText & "‚è±Ô∏è  Intervalle: {self.config['monitoring_interval']}s\\n"
        
        set configButtons to {{"‚úÖ Activer Auto-Nettoyage", "‚ùå D√©sactiver Auto-Nettoyage", "üîî Basculer Notifications", "üìä Panneau Complet", "üîô Retour"}}
        
        set userChoice to choose from list configButtons with title "‚öôÔ∏è Configuration Guardian" with prompt configText default items {{"üîô Retour"}} OK button name "Appliquer" cancel button name "Retour"
        
        if userChoice is not false then
            return item 1 of userChoice
        else
            return "Retour"
        end if
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', config_script], 
                                  capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                action = result.stdout.strip()
                
                if action == "‚úÖ Activer Auto-Nettoyage":
                    self.config['auto_cleanup_enabled'] = True
                    self.save_config()
                    self.send_notification("‚úÖ Configuration", "Auto-nettoyage activ√©")
                
                elif action == "‚ùå D√©sactiver Auto-Nettoyage":
                    self.config['auto_cleanup_enabled'] = False
                    self.save_config()
                    self.send_notification("‚ùå Configuration", "Auto-nettoyage d√©sactiv√©")
                
                elif action == "üîî Basculer Notifications":
                    self.config['notifications_enabled'] = not self.config['notifications_enabled']
                    self.save_config()
                    status = "activ√©es" if self.config['notifications_enabled'] else "d√©sactiv√©es"
                    self.send_notification("üîî Configuration", f"Notifications {status}")
                
                elif action == "üìä Panneau Complet":
                    # Ouvrir le panneau complet
                    current_dir = os.path.dirname(os.path.abspath(__file__))
                    subprocess.Popen(['python3', os.path.join(current_dir, 'maccleaner_guardian.py')])
        
        except Exception as e:
            print(f"‚ùå Erreur configuration: {e}")
    
    def send_notification(self, title, message):
        """Envoie une notification macOS"""
        try:
            script = f'''
            display notification "{message}" with title "{title}" subtitle "MacCleaner Guardian" sound name "Funk"
            '''
            subprocess.run(['osascript', '-e', script], 
                         capture_output=True, timeout=5)
        except:
            pass
    
    def update_system_status(self):
        """Met √† jour le statut syst√®me et notifie si n√©cessaire"""
        metrics = self.get_system_metrics()
        
        if not metrics:
            return
        
        disk_percent = metrics.get('disk_percent', 0)
        memory_percent = metrics.get('memory_percent', 0)
        cpu_percent = metrics.get('cpu_percent', 0)
        
        # D√©terminer l'√©tat
        new_status = "optimal"
        status_icon = "üõ°Ô∏è"
        
        if disk_percent > 85 or memory_percent > 80:
            new_status = "critical"
            status_icon = "‚ö†Ô∏è"
            status_text = "‚ö†Ô∏è Attention requise"
        elif disk_percent > 70 or memory_percent > 65:
            new_status = "warning"
            status_icon = "üü°"
            status_text = "üü° Surveillance active"
        else:
            status_text = "‚úÖ Syst√®me optimal"
        
        # Notifier si changement d'√©tat
        if new_status != self.current_status:
            details = f"Disque: {disk_percent}% | RAM: {memory_percent}% | CPU: {cpu_percent}%"
            self.send_status_notification(status_text, details)
            self.current_status = new_status
        
        # V√©rifier nettoyage automatique
        if (self.config['auto_cleanup_enabled'] and 
            disk_percent > self.config['auto_cleanup_threshold']):
            self.schedule_auto_cleanup(disk_percent)
        
        print(f"{status_icon} {status_text} | Disque: {disk_percent}% | RAM: {memory_percent}% | CPU: {cpu_percent}%")
        
        return metrics
    
    def schedule_auto_cleanup(self, disk_percent):
        """Programme un nettoyage automatique"""
        if self.config['notifications_enabled']:
            # Notification avec option d'annulation
            script = f'''
            display dialog "üõ°Ô∏è MacCleaner Guardian\\n\\nNettoyage automatique recommand√©\\n\\nDisque utilis√©: {disk_percent}%\\n\\nLancer le nettoyage maintenant ?" buttons {{"‚è±Ô∏è  Plus tard", "üßπ Nettoyer"}} default button "üßπ Nettoyer" with title "Auto-Nettoyage" with icon note giving up after 30
            '''
            
            try:
                result = subprocess.run(['osascript', '-e', script], 
                                      capture_output=True, text=True, timeout=35)
                
                if result.returncode == 0 and "Nettoyer" in result.stdout:
                    # L'utilisateur a accept√©
                    self.perform_cleanup()
                
            except:
                # Timeout ou annulation - nettoyage automatique silencieux
                self.perform_cleanup()
    
    def create_status_indicator(self):
        """Cr√©e un indicateur de statut permanent dans les notifications"""
        # Notification persistante mise √† jour r√©guli√®rement
        script = '''
        tell application "System Events"
            -- V√©rifier si le processus Guardian existe d√©j√†
            if not (exists process "Guardian") then
                -- Cr√©er une notification persistante
                display notification "MacCleaner Guardian surveille votre Mac en arri√®re-plan" with title "üõ°Ô∏è Guardian Actif" subtitle "Cliquez sur cette notification pour acc√©der au menu"
            end if
        end tell
        '''
        
        try:
            subprocess.run(['osascript', '-e', script], 
                         capture_output=True, timeout=5)
        except:
            pass
    
    def show_interactive_menu(self):
        """Affiche le menu interactif"""
        metrics = self.update_system_status()
        if metrics:
            action = self.create_interactive_menu(metrics)
            if action and action != "Fermer" and action != "‚ùå Fermer":
                self.handle_user_action(action)
                return True
        return False
    
    def monitoring_loop(self):
        """Boucle de surveillance principale"""
        print("üõ°Ô∏è  MacCleaner Guardian MenuBar - D√©marrage surveillance...")
        
        # Cr√©er l'indicateur initial
        self.create_status_indicator()
        
        while self.monitoring_active:
            try:
                self.update_system_status()
                time.sleep(self.config['monitoring_interval'])
                
                # Recr√©er l'indicateur p√©riodiquement
                if int(time.time()) % 300 == 0:  # Toutes les 5 minutes
                    self.create_status_indicator()
                
            except Exception as e:
                print(f"‚ùå Erreur surveillance: {e}")
                time.sleep(60)
    
    def run(self):
        """Lance le Guardian"""
        try:
            # D√©marrer la surveillance en arri√®re-plan
            monitoring_thread = threading.Thread(target=self.monitoring_loop, daemon=True)
            monitoring_thread.start()
            
            print("üõ°Ô∏è  MacCleaner Guardian MenuBar actif!")
            print("üí° Cliquez sur les notifications pour acc√©der au menu")
            print("üîÑ Le syst√®me est surveill√© automatiquement")
            print("‚èπÔ∏è  Ctrl+C pour arr√™ter")
            
            # Afficher le menu initial
            time.sleep(2)
            self.show_interactive_menu()
            
            # Boucle principale avec menu p√©riodique
            while self.monitoring_active:
                time.sleep(60)  # Attendre 1 minute
                
                # Optionnel: afficher le menu automatiquement si probl√®me d√©tect√©
                if self.current_status in ['critical', 'warning']:
                    print("üí° Probl√®me d√©tect√© - menu disponible via notification")
                
        except KeyboardInterrupt:
            print("\nüõ°Ô∏è  MacCleaner Guardian arr√™t√©.")
            self.monitoring_active = False

def main():
    """Point d'entr√©e principal"""
    import sys
    
    # Gestion des arguments de ligne de commande
    if len(sys.argv) > 1:
        command = sys.argv[1]
        guardian = SimpleMenuBarGuardian()
        
        if command == '--menu':
            # Afficher le menu interactif
            guardian.show_interactive_menu()
        elif command == '--status':
            # Afficher le statut actuel
            guardian.update_system_status()
        elif command == '--cleanup':
            # Nettoyage manuel
            guardian.perform_cleanup()
        elif command == '--optimize':
            # Optimisation manuelle
            guardian.perform_optimization()
        return
    
    # Mode normal - surveillance continue
    guardian = SimpleMenuBarGuardian()
    guardian.run()

if __name__ == "__main__":
    main()