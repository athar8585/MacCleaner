import os, re, hashlib, json, threading, time
from pathlib import Path
from datetime import datetime
from database.db import record_malware

SIGNATURE_FILE = Path('malware_scanner/signatures_min.json')

class MalwareScanner:
    def __init__(self, log_fn=None, quarantine_dir='malware_scanner/quarantine'):
        self.log = log_fn or print  # Utiliser print par d√©faut
        self.signatures = []
        self.quarantine_dir = Path(quarantine_dir)
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)
        self._load_signatures()
        self.stop_flag = False

    def _load_signatures(self):
        if SIGNATURE_FILE.exists():
            try:
                with open(SIGNATURE_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                self.signatures = data.get('signatures', [])
                self.log(f"üõ°Ô∏è Base de signatures charg√©e ({len(self.signatures)})")
            except Exception as e:
                self.log(f"‚ùå Erreur chargement signatures: {e}")
        else:
            self.log("‚ö†Ô∏è Aucune base de signatures trouv√©e")

    def update_signatures_from_url(self, url):
        try:
            import urllib.request
            with urllib.request.urlopen(url, timeout=10) as resp:
                raw = resp.read().decode('utf-8')
            data = json.loads(raw)
            with open(SIGNATURE_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            self._load_signatures()
            self.log("‚úÖ Signatures mises √† jour depuis Internet")
        except Exception as e:
            self.log(f"‚ùå Mise √† jour signatures √©chou√©e: {e}")

    def hash_file(self, path):
        h = hashlib.sha256()
        try:
            with open(path, 'rb') as f:
                for chunk in iter(lambda: f.read(8192), b''):
                    h.update(chunk)
            return h.hexdigest()
        except Exception:
            return None

    def scan_path(self, path):
        findings = []
        if os.path.isfile(path):
            self._scan_file(path, findings)
        else:
            for root, dirs, files in os.walk(path):
                if self.stop_flag:
                    break
                for name in files:
                    fpath = os.path.join(root, name)
                    self._scan_file(fpath, findings)
        return findings

    def scan_file(self, file_path):
        """Alias pour scan_path pour un seul fichier"""
        findings = self.scan_path(file_path)
        if findings:
            return {"status": "threats_found", "findings": findings}
        else:
            return {"status": "clean", "findings": []}

    def _scan_file(self, fpath, findings):
        # Exclure les fichiers du projet MacCleaner lui-m√™me
        if 'MacCleaner' in fpath or 'malware_scanner' in fpath:
            return
            
        # Exclure les fichiers syst√®me macOS l√©gitimes
        filename = os.path.basename(fpath).lower()
        macos_system_files = [
            '.localized', '.ds_store', '.com.apple.timemachine.supported',
            'icon\r', 'thumbs.db', 'desktop.ini', '.spotlight-v100',
            '.trashes', '.fseventsd', '.hotfiles.btree', '.vol',
            'com.apple.', '.apdisk', '.documentrevisions-v100'
        ]
        
        # Ignorer les fichiers syst√®me macOS
        for sys_file in macos_system_files:
            if sys_file in filename:
                return
                
        # Ignorer les dossiers syst√®me critiques
        system_paths = [
            '/System/', '/Library/Apple/', '/Applications/',
            '/Library/Application Support/Apple/', '/private/var/',
            '/usr/bin/', '/usr/sbin/', '/bin/', '/sbin/'
        ]
        
        for sys_path in system_paths:
            if sys_path in fpath:
                return
            
        # Hash matching
        file_hash = self.hash_file(fpath)
        for sig in self.signatures:
            if sig['type'] == 'hash' and file_hash and file_hash == sig['value']:
                self._report(fpath, sig, findings)
                return
        # Pattern matching (content limited)
        try:
            with open(fpath, 'r', errors='ignore') as f:
                head = f.read(20000)
            for sig in self.signatures:
                if sig['type'] == 'pattern':
                    if re.search(sig['value'], head, re.IGNORECASE):
                        self._report(fpath, sig, findings)
                        return
        except Exception:
            pass

    def _report(self, path, sig, findings):
        self.log(f"üö® MENACE D√âTECT√âE: {sig['name']} -> {path}")
        findings.append({"path": path, "signature": sig['name'], "severity": sig.get('severity','unknown')})
        record_malware(path, sig['name'], sig.get('severity','unknown'), datetime.utcnow().isoformat())
        
        # Actions de s√©curit√©
        try:
            import shutil
            severity = sig.get('severity', 'unknown').lower()
            
            # 1. Quarantaine (copier le fichier)
            qpath = self.quarantine_dir / (Path(path).name + '.quar')
            shutil.copy2(path, qpath)
            self.log(f"üîí Fichier mis en quarantaine: {qpath}")
            
            # 2. Actions selon la s√©v√©rit√©
            if severity in ['high', 'critical']:
                # Fichier dangereux - suppression imm√©diate
                try:
                    os.remove(path)
                    self.log(f"üóëÔ∏è SUPPRIM√â (haute s√©v√©rit√©): {path}")
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Impossible de supprimer {path}: {e}")
                    
            elif severity == 'medium':
                # Fichier suspect - neutraliser
                try:
                    with open(path, 'w') as f:
                        f.write("# Fichier neutralis√© par MacCleaner Pro - Contenu suspect d√©tect√©")
                    self.log(f"üõ°Ô∏è NEUTRALIS√â (s√©v√©rit√© moyenne): {path}")
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Impossible de neutraliser {path}: {e}")
                    
            else:
                # S√©v√©rit√© faible - signaler seulement
                self.log(f"‚ö†Ô∏è SIGNAL√â (faible s√©v√©rit√©): {path}")
                
        except Exception as e:
            self.log(f"‚ùå Erreur traitement menace {path}: {e}")

    def async_scan(self, target_paths):
        thread = threading.Thread(target=self._async_worker, args=(target_paths,), daemon=True)
        thread.start()
        return thread

    def _async_worker(self, targets):
        self.log("üõ°Ô∏è D√©marrage scan malware...")
        total_findings = []
        for t in targets:
            if self.stop_flag: break
            if os.path.exists(t):
                findings = self.scan_path(t)
                total_findings.extend(findings)
        if total_findings:
            self.log(f"üö® Malware d√©tect√©: {len(total_findings)} √©l√©ment(s)")
        else:
            self.log("‚úÖ Aucun malware d√©tect√© sur les chemins scann√©s")
        self.log("üõ°Ô∏è Scan termin√©")
